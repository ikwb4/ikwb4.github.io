<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> URDF builder PROTOTYPE </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00b4d8;
            --primary-dark: #0096c7;
            --danger: #ff4444;
            --success: #38b2ac;
            --dark-grey: #2b2d31;
            --darker-grey: #1e1f22;
            --light-grey: #383a3f;
            --text-light: #ffffff;
            --text-muted: #b5bac1;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
            background: var(--darker-grey);
            color: var(--text-light);
        }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            background: var(--dark-grey);
            border-bottom: 1px solid var(--light-grey);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }

        .main-container {
            display: flex;
            width: 100%;
            margin-top: 50px;
        }

        .sidebar {
            width: 300px;
            padding: 20px;
            overflow-y: auto;
            max-height: calc(100vh - 50px);
            background: var(--dark-grey);
            border-right: 1px solid var(--light-grey);
        }

        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            padding: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            background: var(--dark-grey);
            border-bottom: 1px solid var(--light-grey);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--darker-grey);
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        h2 {
            margin-bottom: 15px;
            font-size: 18px;
            color: var(--text-light);
        }

        .component-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: var(--light-grey);
            color: var(--text-light);
            border: 1px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .component-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        .component-btn.custom {
            background: transparent;
            border: 2px dashed var(--light-grey);
            color: var(--text-muted);
            margin-top: 20px;
        }

        .component-btn.custom:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: rgba(0, 180, 216, 0.1);
        }

        .properties {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--light-grey);
        }

        .property-group {
            margin-bottom: 15px;
        }

        .property-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-muted);
        }

        .property-group input, .property-group select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
            background: var(--darker-grey);
            border: 1px solid var(--light-grey);
            color: var(--text-light);
        }

        .property-group input:focus, .property-group select:focus {
            outline: none;
            border-color: var(--primary);
        }

        .color-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-input-wrapper input[type="color"] {
            width: 50px;
            height: 35px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        .color-input-wrapper input[type="text"] {
            flex: 1;
        }

        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            border: 1px solid var(--light-grey);
            background: var(--light-grey);
            color: var(--text-light);
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            border-color: var(--primary-dark);
        }

        #urdf-output, #custom-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 800px;
            max-height: 80vh;
            display: none;
            z-index: 1000;
            background: var(--dark-grey);
            border: 1px solid var(--light-grey);
        }

        #custom-dialog {
            max-width: 400px;
        }

        #urdf-output textarea {
            width: 100%;
            height: 400px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 4px;
            background: var(--darker-grey);
            border: 1px solid var(--light-grey);
            color: var(--text-light);
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--danger);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            color: var(--primary);
        }

        .controls-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            background: var(--dark-grey);
            color: var(--text-muted);
            border: 1px solid var(--light-grey);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: var(--text-muted);
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            background: var(--darker-grey);
            border: 1px solid var(--light-grey);
            color: var(--text-light);
        }

        .dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        /* Outline effect for selected mesh */
        .selection-outline {
            position: absolute;
            pointer-events: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="header">
        <div class="logo">drf PROTOTYPE</div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <h2>Robot Components</h2>
            <button class="component-btn" onclick="addComponent('base')">Add Base</button>
            <button class="component-btn" onclick="addComponent('link')">Add Link</button>
            <button class="component-btn" onclick="addComponent('joint')">Add Joint</button>
            <button class="component-btn" onclick="addComponent('wheel')">Add Wheel</button>
            <button class="component-btn" onclick="addComponent('sensor')">Add Sensor</button>
            <button class="component-btn custom" onclick="openCustomDialog()">Add Custom Component</button>
            
            <div class="properties">
                <h2>Properties</h2>
                <div id="properties-panel">
                    <p style="color: var(--text-muted); font-size: 14px;">Select a component to edit properties</p>
                </div>
            </div>
        </div>

        <div class="main-area">
            <div class="toolbar">
                <button class="btn" onclick="clearCanvas()">Clear All</button>
                <button class="btn" onclick="deleteSelected()">Delete Selected</button>
                <button class="btn btn-primary" onclick="generateURDF()">Generate URDF</button>
                <button class="btn" onclick="saveProject()">Save Project</button>
                <button class="btn" onclick="loadProject()">Load Project</button>
            </div>
            
            <div class="canvas-container">
                <div class="loading">Initializing 3D View...</div>
                <canvas id="canvas"></canvas>
                <div class="controls-info" style="display: none;">
                    Left Click: Select/Drag | Scroll: Zoom | Right Drag: Rotate View
                </div>
            </div>
        </div>
    </div>

    <div id="urdf-output">
        <button class="close-btn" onclick="closeURDF()">×</button>
        <h2>Generated URDF</h2>
        <textarea id="urdf-text" readonly></textarea>
        <div style="margin-top: 15px; text-align: center;">
            <button class="btn btn-primary" onclick="copyURDF()">Copy to Clipboard</button>
            <button class="btn" onclick="downloadURDF()">Download URDF</button>
        </div>
    </div>

    <div id="custom-dialog">
        <button class="close-btn" onclick="closeCustomDialog()">×</button>
        <h2>Custom Component</h2>
        <div class="form-group">
            <label>Component Name</label>
            <input type="text" id="custom-name" placeholder="custom_part">
        </div>
        <div class="form-group">
            <label>Geometry Type</label>
            <select id="custom-geometry">
                <option value="box">Box</option>
                <option value="cylinder">Cylinder</option>
                <option value="sphere">Sphere</option>
                <option value="cone">Cone</option>
                <option value="torus">Torus</option>
            </select>
        </div>
        <div class="form-group">
            <label>Size (Width/Radius)</label>
            <input type="number" id="custom-size-x" value="1" step="0.1">
        </div>
        <div class="form-group">
            <label>Height</label>
            <input type="number" id="custom-size-y" value="1" step="0.1">
        </div>
        <div class="form-group">
            <label>Depth (for Box)</label>
            <input type="number" id="custom-size-z" value="1" step="0.1">
        </div>
        <div class="form-group">
            <label>Color</label>
            <input type="color" id="custom-color" value="#9333ea">
        </div>
        <div class="dialog-buttons">
            <button class="btn" onclick="closeCustomDialog()">Cancel</button>
            <button class="btn btn-primary" onclick="createCustomComponent()">Create</button>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer;
        let robot = {
            components: [],
            connections: []
        };
        let selectedComponent = null;
        let selectedMesh = null;
        let outlinePass = null;
        let componentId = 0;
        let raycaster, mouse;
        let isDragging = false;
        let isRotating = false;
        let draggedMesh = null;
        let previousMousePosition = { x: 0, y: 0 };

        // Initialize the application
        function init() {
            if (typeof THREE === 'undefined') {
                loadThreeJSAlternative();
                return;
            }
            setupThreeJS();
        }

        function loadThreeJSAlternative() {
            const cdnSources = [
                'https://unpkg.com/three@0.128.0/build/three.min.js',
                'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js',
            ];

            let currentIndex = 0;

            function tryNextSource() {
                if (currentIndex >= cdnSources.length) {
                    console.error('All Three.js CDN sources failed');
                    return;
                }

                const script = document.createElement('script');
                script.src = cdnSources[currentIndex];
                script.onload = function() {
                    console.log('Three.js loaded from:', cdnSources[currentIndex]);
                    setupThreeJS();
                };
                script.onerror = function() {
                    console.error('Failed to load from:', cdnSources[currentIndex]);
                    currentIndex++;
                    tryNextSource();
                };
                document.head.appendChild(script);
            }

            tryNextSource();
        }

        function setupThreeJS() {
            const canvas = document.getElementById('canvas');
            const container = canvas.parentElement;
            
            // Setup scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1f22);
            scene.fog = new THREE.Fog(0x1e1f22, 10, 50);
            
            // Setup camera
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);
            
            // Setup renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x00b4d8, 0.3);
            pointLight.position.set(-5, 10, -5);
            scene.add(pointLight);
            
            // Add grid and axes
            const gridHelper = new THREE.GridHelper(20, 20, 0x383a3f, 0x2b2d31);
            scene.add(gridHelper);
            
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);

            // Add ground plane for shadows
            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.1 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.01;
            plane.receiveShadow = true;
            scene.add(plane);
            
            // Setup raycaster and mouse
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Add event listeners
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            canvas.addEventListener('wheel', onMouseWheel, false);
            canvas.addEventListener('contextmenu', e => e.preventDefault(), false);
            
            window.addEventListener('resize', onWindowResize, false);
            
            // Hide loading message and show controls info
            document.querySelector('.loading').style.display = 'none';
            document.querySelector('.controls-info').style.display = 'block';
            
            // Start animation loop
            animate();
        }

        function animate() {
            if (!renderer) return;
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            
            const container = document.querySelector('.canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function onMouseDown(event) {
            if (!raycaster || !camera) return;
            
            event.preventDefault();
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            if (event.button === 0) { // Left click
                raycaster.setFromCamera(mouse, camera);
                
                const meshes = scene.children.filter(obj => obj.userData.componentId !== undefined);
                const intersects = raycaster.intersectObjects(meshes);
                
                if (intersects.length > 0) {
                    isDragging = true;
                    draggedMesh = intersects[0].object;
                    selectComponent(draggedMesh.userData.componentId);
                }
            } else if (event.button === 2) { // Right click
                isRotating = true;
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        }

        function onMouseMove(event) {
            if (!renderer) return;
            
            if (isDragging && draggedMesh && raycaster && camera) {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                const planeNormal = new THREE.Vector3(0, 1, 0);
                const planeConstant = -draggedMesh.position.y;
                const plane = new THREE.Plane(planeNormal, planeConstant);
                
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                if (intersection) {
                    draggedMesh.position.x = intersection.x;
                    draggedMesh.position.z = intersection.z;
                    
                    const component = robot.components.find(c => c.id === draggedMesh.userData.componentId);
                    if (component) {
                        component.position.x = intersection.x;
                        component.position.z = intersection.z;
                    }
                }
            } else if (isRotating && camera) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };

                const rotationSpeed = 0.005;
                
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaMove.x * rotationSpeed;
                spherical.phi += deltaMove.y * rotationSpeed;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);

                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        }

        function onMouseUp(event) {
            isDragging = false;
            isRotating = false;
            draggedMesh = null;
        }

        function onMouseWheel(event) {
            if (!camera) return;
            
            event.preventDefault();
            
            const zoomSpeed = 0.1;
            const scale = event.deltaY > 0 ? (1 + zoomSpeed) : (1 - zoomSpeed);
            
            camera.position.multiplyScalar(scale);
            camera.updateProjectionMatrix();
        }

        function addComponent(type) {
            const component = {
                id: componentId++,
                type: type,
                name: `${type}_${componentId}`,
                position: { 
                    x: (Math.random() - 0.5) * 6, 
                    y: type === 'base' ? 0.15 : 1, 
                    z: (Math.random() - 0.5) * 6 
                },
                rotation: { x: 0, y: 0, z: 0 },
                size: { x: 1, y: 1, z: 1 },
                color: getColorForType(type),
                colorHex: getColorHexForType(type),
                geometryType: type
            };
            
            robot.components.push(component);
            
            if (scene) {
                createMesh(component);
            }
            
            selectComponent(component.id);
        }

        function getColorForType(type) {
            const colors = {
                base: 0x4a5568,
                link: 0x667eea,
                joint: 0xff6b6b,
                wheel: 0x38b2ac,
                sensor: 0xf6ad55,
                custom: 0x9333ea
            };
            return colors[type] || 0x718096;
        }

        function getColorHexForType(type) {
            const colors = {
                base: '#4a5568',
                link: '#667eea',
                joint: '#ff6b6b',
                wheel: '#38b2ac',
                sensor: '#f6ad55',
                custom: '#9333ea'
            };
            return colors[type] || '#718096';
        }

        function createMesh(component) {
            if (!scene || typeof THREE === 'undefined') return;
            
            let geometry;
            
            if (component.type === 'custom') {
                // Create custom geometry based on component properties
                switch(component.geometryType) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(
                            component.size.x || 1,
                            component.size.y || 1,
                            component.size.z || 1
                        );
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(
                            component.size.x || 0.5,
                            component.size.x || 0.5,
                            component.size.y || 1,
                            32
                        );
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(
                            component.size.x || 0.5,
                            32,
                            16
                        );
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(
                            component.size.x || 0.5,
                            component.size.y || 1,
                            32
                        );
                        break;
                    case 'torus':
                        geometry = new THREE.TorusGeometry(
                            component.size.x || 0.5,
                            component.size.y * 0.3 || 0.2,
                            16,
                            32
                        );
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                }
            } else {
                // Standard component geometries
                switch(component.type) {
                    case 'base':
                        geometry = new THREE.BoxGeometry(3, 0.3, 2);
                        break;
                    case 'link':
                        geometry = new THREE.BoxGeometry(0.4, 2, 0.4);
                        break;
                    case 'joint':
                        geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 16);
                        break;
                    case 'wheel':
                        geometry = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 32);
                        geometry.rotateZ(Math.PI / 2);
                        break;
                    case 'sensor':
                        geometry = new THREE.SphereGeometry(0.3, 16, 16);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(1, 1, 1);
                }
            }
            
            const material = new THREE.MeshPhongMaterial({ 
                color: component.color || component.colorHex,
                shininess: 100,
                specular: 0x222222
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(component.position.x, component.position.y, component.position.z);
            mesh.rotation.set(component.rotation.x, component.rotation.y, component.rotation.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.componentId = component.id;
            mesh.userData.componentType = component.type;
            
            scene.add(mesh);
        }

        function selectComponent(id) {
            selectedComponent = robot.components.find(c => c.id === id);
            
            // Remove previous outline
            if (selectedMesh && selectedMesh.children.length > 0) {
                const outline = selectedMesh.children.find(child => child.name === 'outline');
                if (outline) selectedMesh.remove(outline);
            }
            
            if (scene && typeof THREE !== 'undefined') {
                scene.children.forEach(child => {
                    if (child.userData.componentId !== undefined) {
                        // Remove any existing outlines
                        const existingOutline = child.children.find(c => c.name === 'outline');
                        if (existingOutline) child.remove(existingOutline);
                        
                        if (child.userData.componentId === id) {
                            selectedMesh = child;
                            
                            // Create outline effect using edges
                            const edges = new THREE.EdgesGeometry(child.geometry);
                            const line = new THREE.LineSegments(
                                edges,
                                new THREE.LineBasicMaterial({ 
                                    color: 0x00b4d8,
                                    linewidth: 2
                                })
                            );
                            line.name = 'outline';
                            child.add(line);
                        }
                    }
                });
            }
            
            updatePropertiesPanel();
        }

        function updatePropertiesPanel() {
            const panel = document.getElementById('properties-panel');
            
            if (!selectedComponent) {
                panel.innerHTML = '<p style="color: var(--text-muted); font-size: 14px;">Select a component to edit properties</p>';
                return;
            }
            
            panel.innerHTML = `
                <div class="property-group">
                    <label>Name</label>
                    <input type="text" value="${selectedComponent.name}" onchange="updateProperty('name', this.value)">
                </div>
                <div class="property-group">
                    <label>Type</label>
                    <input type="text" value="${selectedComponent.type}" readonly style="opacity: 0.7;">
                </div>
                <div class="property-group">
                    <label>Color</label>
                    <div class="color-input-wrapper">
                        <input type="color" value="${selectedComponent.colorHex || '#667eea'}" onchange="updateColor(this.value)">
                        <input type="text" value="${selectedComponent.colorHex || '#667eea'}" onchange="updateColor(this.value)">
                    </div>
                </div>
                <div class="property-group">
                    <label>Position X</label>
                    <input type="number" value="${selectedComponent.position.x.toFixed(2)}" step="0.1" onchange="updatePosition('x', this.value)">
                </div>
                <div class="property-group">
                    <label>Position Y</label>
                    <input type="number" value="${selectedComponent.position.y.toFixed(2)}" step="0.1" onchange="updatePosition('y', this.value)">
                </div>
                <div class="property-group">
                    <label>Position Z</label>
                    <input type="number" value="${selectedComponent.position.z.toFixed(2)}" step="0.1" onchange="updatePosition('z', this.value)">
                </div>
            `;
        }

        function updateProperty(property, value) {
            if (selectedComponent) {
                selectedComponent[property] = value;
            }
        }

        function updateColor(value) {
            if (!selectedComponent) return;
            
            selectedComponent.colorHex = value;
            selectedComponent.color = parseInt(value.replace('#', '0x'));
            
            if (scene && typeof THREE !== 'undefined') {
                const mesh = scene.children.find(child => 
                    child.userData.componentId === selectedComponent.id
                );
                if (mesh && mesh.material) {
                    mesh.material.color = new THREE.Color(value);
                }
            }
            
            updatePropertiesPanel();
        }

        function updatePosition(axis, value) {
            if (!selectedComponent) return;
            
            selectedComponent.position[axis] = parseFloat(value);
            
            if (scene && typeof THREE !== 'undefined') {
                const mesh = scene.children.find(child => 
                    child.userData.componentId === selectedComponent.id
                );
                if (mesh) {
                    mesh.position[axis] = parseFloat(value);
                }
            }
        }

        function deleteSelected() {
            if (!selectedComponent) return;
            
            if (scene && typeof THREE !== 'undefined') {
                const mesh = scene.children.find(child => 
                    child.userData.componentId === selectedComponent.id
                );
                if (mesh) {
                    scene.remove(mesh);
                }
            }
            
            robot.components = robot.components.filter(c => c.id !== selectedComponent.id);
            selectedComponent = null;
            selectedMesh = null;
            updatePropertiesPanel();
        }

        function clearCanvas() {
            if (!confirm('Clear all components?')) return;
            
            if (scene && typeof THREE !== 'undefined') {
                const toRemove = scene.children.filter(child => 
                    child.userData.componentId !== undefined
                );
                toRemove.forEach(mesh => scene.remove(mesh));
            }
            
            robot.components = [];
            selectedComponent = null;
            selectedMesh = null;
            componentId = 0;
            updatePropertiesPanel();
        }

        function openCustomDialog() {
            document.getElementById('custom-dialog').style.display = 'block';
            document.getElementById('custom-name').value = `custom_${componentId + 1}`;
        }

        function closeCustomDialog() {
            document.getElementById('custom-dialog').style.display = 'none';
        }

        function createCustomComponent() {
            const name = document.getElementById('custom-name').value || `custom_${componentId + 1}`;
            const geometryType = document.getElementById('custom-geometry').value;
            const sizeX = parseFloat(document.getElementById('custom-size-x').value) || 1;
            const sizeY = parseFloat(document.getElementById('custom-size-y').value) || 1;
            const sizeZ = parseFloat(document.getElementById('custom-size-z').value) || 1;
            const color = document.getElementById('custom-color').value;
            
            const component = {
                id: componentId++,
                type: 'custom',
                name: name,
                position: { 
                    x: (Math.random() - 0.5) * 6, 
                    y: 1, 
                    z: (Math.random() - 0.5) * 6 
                },
                rotation: { x: 0, y: 0, z: 0 },
                size: { x: sizeX, y: sizeY, z: sizeZ },
                color: parseInt(color.replace('#', '0x')),
                colorHex: color,
                geometryType: geometryType
            };
            
            robot.components.push(component);
            
            if (scene) {
                createMesh(component);
            }
            
            selectComponent(component.id);
            closeCustomDialog();
        }

        function generateURDF() {
            if (robot.components.length === 0) {
                alert('Please add some components first!');
                return;
            }

            let urdf = `<?xml version="1.0"?>
<robot name="easy_urdf_robot">
`;
            
            // Generate links
            robot.components.forEach((component, index) => {
                if (component.type !== 'joint') {
                    const r = ((component.color >> 16) & 255) / 255;
                    const g = ((component.color >> 8) & 255) / 255;
                    const b = (component.color & 255) / 255;
                    
                    urdf += `
    <link name="${component.name}">
        <visual>
            <origin xyz="0 0 0" rpy="0 0 0"/>
            <geometry>
                ${getGeometryTag(component)}
            </geometry>
            <material name="material_${component.name}">
                <color rgba="${r.toFixed(2)} ${g.toFixed(2)} ${b.toFixed(2)} 1.0"/>
            </material>
        </visual>
        <collision>
            <origin xyz="0 0 0" rpy="0 0 0"/>
            <geometry>
                ${getGeometryTag(component)}
            </geometry>
        </collision>
        <inertial>
            <mass value="1.0"/>
            <origin xyz="0 0 0" rpy="0 0 0"/>
            <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>
        </inertial>
    </link>
`;
                }
            });
            
            // Generate joints to connect components
            const nonJointComponents = robot.components.filter(c => c.type !== 'joint');
            const jointComponents = robot.components.filter(c => c.type === 'joint');
            
            for (let i = 0; i < nonJointComponents.length - 1; i++) {
                const parent = nonJointComponents[i];
                const child = nonJointComponents[i + 1];
                const joint = jointComponents[i] || {
                    name: `joint_${i}`,
                    position: {
                        x: (parent.position.x + child.position.x) / 2,
                        y: (parent.position.y + child.position.y) / 2,
                        z: (parent.position.z + child.position.z) / 2
                    }
                };
                
                urdf += `
    <joint name="${joint.name}" type="revolute">
        <parent link="${parent.name}"/>
        <child link="${child.name}"/>
        <origin xyz="${child.position.x - parent.position.x} ${child.position.y - parent.position.y} ${child.position.z - parent.position.z}" rpy="0 0 0"/>
        <axis xyz="0 1 0"/>
        <limit lower="-3.14159" upper="3.14159" effort="10" velocity="1.0"/>
    </joint>
`;
            }
            
            urdf += `</robot>`;
            
            document.getElementById('urdf-text').value = urdf;
            document.getElementById('urdf-output').style.display = 'block';
        }

        function getGeometryTag(component) {
            if (component.type === 'custom') {
                switch(component.geometryType) {
                    case 'box':
                        return `<box size="${component.size.x} ${component.size.y} ${component.size.z}"/>`;
                    case 'cylinder':
                        return `<cylinder radius="${component.size.x}" length="${component.size.y}"/>`;
                    case 'sphere':
                        return `<sphere radius="${component.size.x}"/>`;
                    default:
                        return '<box size="1.0 1.0 1.0"/>';
                }
            }
            
            switch(component.type) {
                case 'base':
                    return '<box size="3.0 0.3 2.0"/>';
                case 'link':
                    return '<box size="0.4 2.0 0.4"/>';
                case 'wheel':
                    return '<cylinder radius="0.8" length="0.3"/>';
                case 'sensor':
                    return '<sphere radius="0.3"/>';
                default:
                    return '<box size="1.0 1.0 1.0"/>';
            }
        }

        function closeURDF() {
            document.getElementById('urdf-output').style.display = 'none';
        }

        function copyURDF() {
            const textarea = document.getElementById('urdf-text');
            textarea.select();
            document.execCommand('copy');
            alert('URDF copied to clipboard!');
        }

        function downloadURDF() {
            const text = document.getElementById('urdf-text').value;
            const blob = new Blob([text], { type: 'text/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'robot.urdf';
            a.click();
            URL.revokeObjectURL(url);
        }

        function saveProject() {
            const projectData = JSON.stringify(robot, null, 2);
            const blob = new Blob([projectData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'easy_urdf_project.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        if (!data.components || !Array.isArray(data.components)) {
                            throw new Error('Invalid project file format');
                        }
                        
                        if (scene && typeof THREE !== 'undefined') {
                            const toRemove = scene.children.filter(child => 
                                child.userData.componentId !== undefined
                            );
                            toRemove.forEach(mesh => scene.remove(mesh));
                        }
                        
                        robot = data;
                        selectedComponent = null;
                        selectedMesh = null;
                        componentId = Math.max(...robot.components.map(c => c.id), 0) + 1;
                        
                        robot.components.forEach(component => {
                            if (scene && typeof THREE !== 'undefined') {
                                createMesh(component);
                            }
                        });
                        
                        updatePropertiesPanel();
                        alert('Project loaded successfully!');
                    } catch (error) {
                        alert('Error loading project: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // Initialize when the page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>